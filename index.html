<!DOCTYPE html>
<html>
<!-- Based on example from http://stackoverflow.com/questions/12479895/obtaining-bigquery-data-from-javascript-code -->

<head>
    <script src="//code.jquery.com/jquery-2.1.0.min.js"></script>
    <script src="//code.highcharts.com/stock/highstock.js"></script>
    <script src="//code.highcharts.com/stock/modules/exporting.js"></script>

    <script type="text/javascript">
    var SHOWN_COUNTRIES = {
        cn: true,
        ir: true,
        us: true,
        total: true
    };

    Highcharts.setOptions({
        global: {
            useUTC: false
        }
    });

    /**
     * Constructs a new chart and starts reading data
     */

    function makeChart(id, title, dimName, dimKey, statType, statName, onData, options) {
        var fullOptions = $.extend({
            rangeSelector: {
                buttons: [{
                    count: 1,
                    type: 'minute',
                    text: '1M'
                }, {
                    count: 10,
                    type: 'minute',
                    text: '10M'
                }, {
                    count: 1,
                    type: 'hour',
                    text: '1H'
                }, {
                    count: 24,
                    type: 'hour',
                    text: '24H'
                }, {
                    type: 'all',
                    text: 'All'
                }],
                inputEnabled: false,
                selected: 1
            },

            title: {
                text: title
            },

            exporting: {
                enabled: false
            },

            series: []
        }, options)

        var chart = null;
        var seriesByName = {};

        var context = {
            priorValues: {},
            getSeries: function(asOf, name) {
                var s = seriesByName[name];
                if (!s) {
                    s = chart.addSeries({
                        name: name,
                        data: []
                    })
                    seriesByName[name] = s;
                }
                return s;
            }
        }

        var ws = new WebSocket("ws://localhost:9000/stream/" + dimName + "/" + dimKey + "/" + statType + "/" + statName);
        ws.onopen = function() {
            console.log("WebSocket opened")
        };
        ws.onmessage = function(evt) {
            var msg = evt.data;
            var resp = JSON.parse(msg);
            if (resp.succeeded) {
                if (!chart) {
                    // Lazily make the charge once we have some data
                    $('#' + id).highcharts('StockChart', fullOptions);
                    chart = $('#' + id).highcharts();
                }
                for (var i = 0; i < resp.intervals.length; i++) {
                    var interval = resp.intervals[i];
                    var asOf = interval.asOfSeconds * 1000;
                    onData(context, asOf, interval.values);
                }
                chart.redraw();
            } else {
                console.log("Response was unsuccessful", resp["error"]);
            }
        };
        ws.onclose = function() {
            // websocket is closed.
            console.log("WebSocket closed");
        };
    }

    $(function() {
        makeChart(
            'kbpsFallbacks',
            'KBps Fallbacks',
            'fallback',
            '*',
            'counter',
            'bytesGiven',
            function(context, asOf, values) {
                var points = [];
                Object.keys(values).forEach(function(name) {
                    var bytesGiven = values[name];
                    // Remove leading "instance_"
                    name = name == "total" ? name : name.substring(9)
                    var priorValue = context.priorValues[name];
                    if (typeof(priorValue) !== "undefined") {
                        var delta = bytesGiven - (priorValue.value || 0);
                        var deltaKBps = Math.ceil(delta / 1024.0 / (asOf - priorValue.asOf) * 1000);
                        // Filter out fallbacks that are basically doing no work
                        if (deltaKBps > 10) {
                            points.push({
                                name: name,
                                delta: deltaKBps
                            });
                        }
                    }
                    context.priorValues[name] = {
                        asOf: asOf,
                        value: bytesGiven
                    };
                });

                // Sort points based on size of delta, in order to get highest
                // valued names to show up first on legend.
                points.sort(function(a, b) {
                    return b.delta - a.delta;
                });

                for (var i = 0; i < points.length; i++) {
                    var point = points[i];
                    var s = context.getSeries(asOf, point.name);
                    s.addPoint([asOf, point.delta], false, false);
                }
            }, {
                yAxis: {
                    type: 'logarithmic',
                }
            });

        makeChart(
            'kbpsPeers',
            'KBps Peers',
            'country',
            '*',
            'counter',
            'bytesGivenByPeer',
            function(context, asOf, values) {
                Object.keys(values).forEach(function(name) {
                    if (!(name in SHOWN_COUNTRIES)) {
                        // Only show the countries we're interested in
                        return;
                    }
                    var bytesGiven = values[name] || 0;
                    var s = context.getSeries(asOf, name);
                    var priorValue = context.priorValues[name];
                    if (typeof(priorValue) !== "undefined") {
                        var delta = bytesGiven - (priorValue || 0);
                        var deltaKBps = Math.ceil(delta / 1024.0 / (asOf - priorValue.asOf) * 1000);
                        s.addPoint([asOf, deltaKBps], false, false);
                    }
                    context.priorValues[name] = {
                        asOf: asOf,
                        value: bytesGiven
                    };
                });
            });


        makeChart(
            'usersOnline',
            'Users Online by Country',
            'country',
            '*',
            'gauge',
            'userOnline',
            function(context, asOf, values) {
            Object.keys(values).forEach(function(name) {
                if (!(name in SHOWN_COUNTRIES)) {
                    return;
                }
                var online = values[name] || 0;
                var s = context.getSeries(asOf, name);
                s.addPoint([asOf, online], false, false);
            });
        });

    }); // end $(function() {
    </script>

    <style type="text/css">
    .chart {
        width: 500px;
        height: 300px;
        float: left;
        border: 1px solid;
        margin-left: 10px;
        margin-top: 10px;
        background:url(spinner.gif) center center no-repeat;
    }
    </style>
</head>

<body>
    <div id="kbpsFallbacks" class="chart"></div>
    <div id="kbpsPeers" class="chart"></div>
    <div id="usersOnline" class="chart"></div>
</body>

</html>
